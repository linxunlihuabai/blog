# fiber出现的原因

React渲染页面可以分为两个阶段

1. 协调阶段（reconciliation）: 在这个阶段react会根据状态更新生成新的VDom，然后和旧Vdom进行diff得到需要更新的元素，加入更新队列中
2. 渲染阶段（commit）：遍历更新队列，将所有变更一次性更新到真实dom上

React15的架构分为两层

1. 协调器（reconciler）: 负责找出需要更新的差异
2. 渲染器(render)： 将需要更新的差异进行渲染。

在React15的的时候协调过程中是通过递归来实现的（创建虚拟dom、diff），递归的过程不能中断；如果树的层级很深，这个时间很可能超过16ms，导致用户觉得卡顿。

React的理念是什么：用 JavaScript 构建快速响应的大型 Web 应用程序，react追求的就是快速响应。

React的解决方法就是将无法中断的递归重构为异步可中断的循环，时间分片和fiber架构也因此诞生。

时间分片指的是将一个长时间的任务分割成多个短任务，并且在执行短任务的间隔中将主线程的控制权让出来，这样就不会造成卡顿。通过requestIdleCallback可以快速实现这个效果，它会在每一帧的空闲时间去执行回调函数。但是因为兼容性和触发频率不稳定的原因，React自己实现了一套polyfill。

fiber架构通过链表结构代替了原来的树结构，用循环的遍历方式代替了原来的递归遍历。

React16的架构可以分为三层

1. 调度器(Schedule) - 调度任务的优先级，优先级高的任务先进入协调器
2. 协调器(reconciler) - 负责找出需要更新的组件，由递归变成了循环
3. 渲染器(render) - 将需要的变化更新到页面上

# React Fiber 是如何实现更新过程可控？

更新过程可控主要体现在三方面

1. 任务拆分
2. 任务可以挂起、恢复和终止
3. 任务具有优先级

## 任务拆分

react会把遍历整个dom树的任务拆分为一个个小任务，每个小任务值负责一个节点的处理

## 任务可以挂起、恢复和终止



# fiber为什么要使用链表结构，数组不行么?

数组不行，因为数组对于删除和插入操作的复杂度要更高O（N），链表的插入和删除只需要O（1）。

# React如何处理任务的优先级

 React通过schedule(调度器)来进行任务优先级的调度，每次处理都会比较当前任务和正在执行的任务的优先级，如果当前任务优先级更高就会中断正在执行的任务，把当前任务加入taskQueue中，否则就把当前任务加入timeQueue中。这两个队列都是通过小项堆实现的优先队列。