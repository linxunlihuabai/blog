# React的diff算法

react的diff算法是用来比较新旧两颗dom树之间的差异，常规树的diff算法的时间复杂度是O(N³)，无法满足前端框架的性能需求。React为了降低diff算法的复杂度，提出了一下的优化策略：

1. 只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用它。
2. 两个不同类型的元素会产生两颗不同的树，如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。
3. 通过key来为元素的diff提供复用的线索。

只进行同层级比较，就可以把复杂度降到O(N)

根据同层级的节点数量，可以将diff分成两类

1. 单节点：同级只有一个节点
2. 多节点：同级有多个节点

单节点

如果不存在老节点，直接创建一个新节点
如果存在老节点：先判断key是否相同，如果key相同，再比较是不是同一类型的元素，如果是就复用（老节点加上新节点的props创建新的fiber）这个节点，并把其他兄弟节点删了；如果不是就把这个老节点和它的兄弟节点都删了，然后新创建节点。如果key不同，删除这个老节点,然后继续和它的兄弟节点比较。

多节点

如果新节点为多节点

第一次遍历，比较对应位置的新旧节点，判断能不能复用，如果不能复用就立即跳出循环。

第一次遍历结束

如果新节点老节点都遍历完了，此时diff直接结束。

如果老节点遍历完了、新节点还有剩余，就把剩下的新节点插入。

如果新节点遍历完了、老节点还有剩余，就把剩下的老节点删除。

如果新老节点都有剩余, 说明需要移动位置。为了快速找到新节点对应的老节点，把剩下的老节点存入以key为key，以节点为value的map中。这样遍历新节点就能快速的找到相同key的老节点。接下来就需要判断节点是否需要移动了，移动的参照物就是lastPlacedIndex（最后一个可复用节点的索引位置）。然后我们遍历新节点，利用新节点的key去map中找对应的老节点，如果没有找到，就创建一个新节点；如果这个老节点的索引小于lastPlacedIndex，则表示这个节点需要向右移动（因为每次遍历到的可复用节点一定在目前已知的最后一个可复用节点（lastPlacedIndex）的右边，这个节点之前在它左边，所以现在它需要右移）；如果这个老节点的索引大于等于lastPlacedIndex，则表示这个节点不需要移动，同时更新lastPlacedIndex为这个老节点的索引。最后新节点遍历完了，如果还有老节点，删了就行。

A-B-C-D => D-A-B-C

D-A
D-A-B
D-A-B-C

只是把D变成了第一个，A、B、C都需要右移。所以应该尽量减少将一个队尾的元素移动到队首去的操作。


