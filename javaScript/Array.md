# 数组实例方法

非变异（不改变原数组）:

1. slice(start,end): 返回指定索引位置的一个新数组，如果不传参则返回原数组的一个副本
2. concat(arg1, arg2, ...arg): 返回一个新数组，接受一个任意数量的参数，可是值也可以是数组。这些值和数组的元素都会被添加到新数组中。
3. map(): 遍历数组，返回一个新数组。通常用来改造数组结构
4. filter(): 过滤出条件为true的成员，返回一个新数组


变异（改变原数组）：

1. push(...item) - 向数组末尾插入元素(可以一次添加多个元素)，返回数组长度
2. pop(item) - 从数组末尾弹出一个元素，返回被删除的元素
3. unshift(...item) - 向数组开头插入元素(可以一次添加多个元素)，返回数组长度
4. shift(item) - 从数组开头弹出一个元素，返回被删除的元素
5. splice(start, deleteCount?, ...item?) - 对数组的指定位置进行删除、增加或替换元素的操作，返回被删除元素的数组。（如果start大于数组长度，则是向数组末尾增加元素，如果时负值，会加上数组长度）

# 数组类方法

1. Array.form() - 将一个类数组或可迭代对象，转成一个新数组。
2. Array.isArray() - 判断是否是数组。
3. Array.of(...item) - 根据一组参数来创建一个新数组，数组值为传入的参数。Array.of(1,2,3)返回[1,2,3];

# Array 和 Array.of的区别

Array(7) 会返回一个长度为7但没有任何元素的数组对象；Array.of(7) 返回的是只有一个元素的数组实例[7]；
Array(1,2,3) 会返回一个以参数为元素的数组实例[1,2,3]；Array.of(1, 2, 3) 也会返回一个以参数为元素的数组实例[1,2,3]


# 为什么push/pop比unshift/shift性能好

因为unshift/shift是在数组的头部进行操作，会导致后面的元素都需要进行移动。而push/pop是在数组的尾端进行操作，前面的元素不需要移动。

# 快速组和慢数组

js中的数组有两种存储方式：快数组和慢数组。初始化空数组时，使用快数组，快数组使用连续的内存空间，当数组长度达到最大时，JSArray 会进行动态的扩容，以存储更多的元素，相对慢数组，性能要好得多。当数组中 hole(空隙) 太多时，会转变成慢数组，即以哈希表的方式（ key-value 的形式）存储数据，以节省内存空间。比如下面就会使用慢数组

```js
var arr = [1, 2, 3]
arr[2000] = 10;
```

当往 arr 增加一个 2000 的索引时，arr 被转成慢数组。节省了大量的内存空间（从索引为 2 到索引为 2000）。

# 遍历数组的方式

1. for循环 - 最快，兼容性也好
2. for...of - 只能拿到数组值，拿不到索引
3. for...in - 因为数组也是对象，所以也可以用for...in进行遍历。但最好不要这么做，因为for...in会遍历对象上所有的可枚举属性，但是遍历数组时我们只想遍历它的数字索引，那些额外的属性不是我们想要的。同时for...in内部对普通对象有优化，用来遍历数组性能也更差一点。

# 为什么new Array(num)返回的数组map没效果

因为new Array(num)返回的数组是[empty x num],返回的数组是没有元素的，相当于一个只有length的对象。所以map遍历的时候会跳过空位。

https://www.cnblogs.com/WindrunnerMax/p/13777776.html
