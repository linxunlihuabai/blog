# 事件循环

js执行代码过程中除了依靠函数调用栈管理函数的执行顺序之外，还会

js中维护了两个任务队列：宏任务和微任务。宏任务大概包括script、setTimeout、setInterval等，微任务主要有Promise、async/await。js在执行时会检查宏任务队列是否为空，如果非空就出队一个宏任务执行；在执行这个宏任务的过程中可能会产生一些微任务，将这些微任务放入微任务队列中；当这个宏任务执行完了，就去检查微任务队列有没有任务，如果有就挨个取出来执行；直到微任务队列为空，再去宏任务队列中取宏任务执行进入下一轮循环。如果宏任务队列也空了就休眠直到出现宏任务。


## Promise和async/await

Promise的then只是把回调函数存放再callbacks中，只有当promise的状态是settled，才会将then的回调函数加入微任务队列，只有上一个then被settled才会将下一个then的回调函数加入微任务。

async/await: async会返回一个promise对象，await等价于Promise.resolve

```js
async function async1(){
    let result = await 'test';
    console.log(result);
    return 1;
}

// 等价于

function async1() {
    return Promise.resolve('test').then((result) => {
        console.log(result);
        
        return new Promise((resolve) => {
            resolve(1)
        })
    })
}
```

## Promise.resolve(v) 和 new Promise(resolve=>resolve(v))的区别

如果v是普通对象，那么它们性质是一样的。

如果v是promise实例,那么Promise.resolve(v)会直接返回v，new Promise(resolve=>resolve(v))则相当于

```js
new Promise(resolve=>
    Promise.resolve().then(()=>{
        v.then(resolve)
    })
)
```

这就会导致它的then晚了两个时序。



