## 常用数据结构
1. 数组

> 数组是可以在内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问。

优点：
1. 通过索引查找元素速度快
2. 按照索引遍历数组方便

缺点：
1. 数组的存储空间是从栈上分配的，大小固定后无法扩容
2. 因为添加和删除都需要移动后面的元素一保证连续，所以添加和删除的速度慢

适用场景： 频繁查询，对存储空间要求不大，很少进行添加和删除的操作
        
2. 栈

> 栈是一种特殊的[线性表](https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E8%A1%A8/3228081?fr=aladdin)，只能在线性表的一端操作。栈顶允许操作，栈底不允许操作。

适用场景：栈的特点是先进后出，因此常用于递归场景，例如斐波那契数列。

3. 队列

> 队列和栈一样也是一种线性表。不同的是，队列只能在一端(队尾)添加元素，在另一端(队首)取出元素，也就是先进先出。

适用场景：Event队列、Promise回调队列。

4. 链表

> 链表是物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现。每个元素包含两个部分，一个是存储元素数据的部分，另一个是指向下一个结点地址的指针部分。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。

优点：

1. 链表的存储空间是由堆上动态申请，存储空间大小灵活
2. 添加和删除元素只需要改变前后两个元素结点的指针指向地址就行，所以添加和删除效率高

缺点：

1. 因为含有指针域，所以占用空间较大
2. 查找元素效率低，需要遍历链表，速度慢

适用场景：数据量小，频繁添加和删除的场景

5. 树

> 树是一种典型非线性结构

    1. 每个节点有零个或者多个子节点
    2. 没有父节点的节点称为根节点
    3. 每个非根节点有且只有一个父节点
    4. 除了根节点外，每个子节点可以分为多个不相交的子树

在日常应用中，最常见的是**二叉树**。二叉树具有以下特点：

1. 每个结点最多有两棵子树，结点的度(子节点的个数)最大为2
2. 左右子树顺序不能颠倒
3. 即使某结点只有一个子树，也要区分左右子树

适用场景：二叉树的添加和删除，同时在查找方面有很多算法优化。在各个操作都很快，这对于查找和插入是类似1：1（同一数量级）的需求，是比较划算的。

6. 散列表

> 散列表也叫哈希表，是根据关键码值（key-value）直接进行访问的数据结构，通过key-value来映射到集合中的位置，加快查找速度。
7. 堆

> 堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象

  1. 堆中的某个节点的值总是不大于或者不小于其父节点的值，根节点最大的堆叫做最大堆，反之是最小堆
  2. 堆是一颗完全二叉树 

适用场景：因为堆是有序的，因此一般用来做数组排序——堆排序

8. 图

> 图是一种非线性数据结构，在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。

## 数组和链表的区别

  数组是将元素在内存中顺序存储，可以随机访问，通过索引能够快速找到对应的元素，时间复杂度O(1)，而且相对链表节约存储空间。但正因为是连续存储，内存空间必须一次性分配够。如果数组要扩容，需要重新分配一块更大的空间，再把数据复制过去，时间复杂度为O(n)；如果想在数组中间进行插入和删除，时间复杂度O(1)，而且每次必须将后面的所有数据进行搬移以保证连续，时间复杂度O(n)。

  链表和数组恰好相反，元素在内存中不是顺序存储的，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一个元素的前驱和后驱，操作指针就可以完成元素的插入和删除，时间复杂度O(1)。同时因为存储空间不连续，无法根据索引算出对应元素的地址，所以链表不能随机访问，需要遍历查找，时间复杂度O(n)。而且由于每个元素都必须存储指向前后元素位置的指针，会消耗更大的存储空间